
			// Check message contents -----------------------------------------
			if(!strcmp(receivedKeyword, "MHSK")){
				// Handshake message w/ configuration parameters.
				pl;printf("\n\r[%08dms][C] HSK received. Updating sockets",tm);pu;

				// Update status to stop broadcast:
				this->_setStatus(CONNECTING);

				// Update sockets: .................................................

				// Get configuration lock:
				this->configurationLock.lock();

				// Get values: . . . . . . . . . . . . . . . . . . . . . . . . . . .
				char *ptr = NULL, *splitPosition;
				int port, periodms;
					// NOTE: Use strtok_r instead of strtok for thread-safety

				ptr = strtok_r(receivedCommand, ",", &splitPosition);
				pl;printf("\n\r[%08dms][C] First item: %s",tm, ptr);pu;

				// Get Master MISO port:
				if(ptr != NULL and (port = atoi(ptr)) > 0){
					this->masterMISO.set_port(port);

					// Set Master IP on MISO (from MOSI):
					this->masterMISO.set_ip_address(
						this->masterMOSI.get_ip_address());
						
					pl;printf("\n\r[%08dms][C] Master MISO set to: %s on %d",
					tm, masterMISO.get_ip_address(), port);pu;
				}else{
					// Bad Master MISO:
					pl;printf(
						"\n\r[%08dms][C] HS1 ERROR. Bad master MISO: %d(-1 if NULL)"
						,tm, ptr == NULL? -1:port);pu;

					// Discard progress and restart:
					this->_setStatus(NO_MASTER);

					// Release configuration lock:
					this->configurationLock.unlock();

					// Restart loop:
					continue;
				}

				// Skip Master MOSI port:
				ptr = strtok_r(NULL, ",", &splitPosition);
				pl;printf("\n\r[%08dms][C] Second item: %s",tm, ptr);pu;
				
				ptr = strtok_r(NULL, ",", &splitPosition);
				pl;printf("\n\r[%08dms][C] Third item: %s",tm, ptr);pu;

				// Get period:
				if(ptr != NULL and (periodms = atoi(ptr)) > 0){
					
					pl;printf("\n\r[%08dms][C] Timeout set to: %dms",
						tm, periodms);pu;

					this->periodMS = periodms;
					this->configurationLock.unlock();

				}else{
					// Bad timeout:
					pl;printf(
						"\n\r[%08dms][C] HS1 ERROR. Bad period: %d(-1 if NULL)"
						,tm, ptr == NULL? -1:periodms);pu;

					// Discard progress and restart:
					this->_setStatus(NO_MASTER);

					// Release configuration lock:
					this->configurationLock.unlock();

					// Restart loop:
					continue;
				}

				// Get fan array configuration for Processor:
				ptr = strtok_r(NULL, ",", &splitPosition);
				pl;printf("\n\r[%08dms][C] Fourth item: %s",tm, ptr);pu;

				// Verify:
				if(ptr == NULL){
					// Error while splitting.
					pl;printf(
						"\n\r[%08dms][C] HSK ERROR. NULL configuration."
						,tm);pu;

					// Discard progress and restart:
					this->_setStatus(NO_MASTER);

					// Release configuration lock:
					this->configurationLock.unlock();

					// Restart loop:
					continue;

				}

				// Send command to processor: ..................................
				char configBuffer[256];
				strcpy(configBuffer, ptr);
				bool success = this->processor.process(ptr, true);

				// Check success: ..............................................
				if(not success){
					// If there was a failure in the configuration, terminate 
					// the attempt:
					pl;printf(
						"\n\r[%08dms][C] HSK error at processor. "
						"Handshake aborted",tm);pu;

					// Discard progress:
					this->_setStatus(NO_MASTER);

					// Release configuration lock:
					this->configurationLock.unlock();

					// Restart loop:
					continue;

				}else{
					// Success. 

					// Send reply to master:
					this->_send("SHSK", 5); // Send reply

					pl;printf(
						"\n\r[%08dms][C] HSK Success",tm);pu;
	
					// Update status and move on:
					this->_setStatus(CONNECTED);

					// Release configuration lock:
					this->configurationLock.unlock();

					// Restart loop:
					continue;

					} // End check success .....................................

			}else if(this->getStatus() == CONNECTED and // - - - - - - - - - - - - - 
				!strcmp(receivedKeyword, "MVER")){

				// Verification message. Not compatible w/ this version.
				pl;printf(
					"\n\r[%08dms][C] WARNING: MVER obsolete",tm);pu;

			}else if(this->getStatus() == CONNECTED and // - - - - - - - - - - - - - 
				!strcmp(receivedKeyword, "MSTD")){
				// Standard command message. Send command to Processor.

				pl;printf(
					"\n\r[%08dms][C] MSTD. Command: %s",tm, receivedCommand);pu;

				// Send command to Processor:
				this->processor.process(receivedCommand);

			}else if(this->getStatus() == CONNECTED and // - - - - - - - - - - - - - 
				!strcmp(receivedKeyword, "MRIP")){

				pl;printf(
					"\n\r[%08dms][C] Connection terminated by Master. Rebooting.",tm);pu;

				// Terminate connection:
				this->_setStatus(NO_NETWORK);

			}else{ // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				// Unrecognized message (or command received while disconnected)
				pl;printf(
					"\n\r[%08dms][C] WARNING: Keyword unrecognized or non-HSK"
					" before setup",tm);pu;

				// Reset index if waiting for HSK:
				if(this->getStatus() == NO_MASTER){
					this->mosiIndex = 0;
				} // End reset index

			}// End check message ----------------------------------------------

		} // End verify reception = = = = = = = = = = = = = = = = = = = = = = = 

		// (Restart loop)



// RECEIVE FUNCTION:


	// Placeholders: ===========================================================
	char received[MAX_MESSAGE_LENGTH];
	int result = -1;
	char *ptr;
	bool hsk = false;

	// Default values: =========================================================
	*receivedIndex = 0;
	keyword[0] = '\0';
	command[0] = '\0';
	result = -1;
	
	
	// Loop until a correct message is received or the socket times out:
	while(true){ // Receive loop ===============================================
		// Get messages and evaluate them. Either return w/ success after find-
		// ing an appropriate message or w/ failure after timing out.

		// Get a message: = = = = = = = = = = = = = = = = = = = = = = = = = = = 
		pl;printf("\n\r[%08dms][R] Waiting on message",tm);pu;
		
		result = 
			this->slaveMOSI.recvfrom(&this->masterMOSI, received, 
				MAX_MESSAGE_LENGTH);

		// Validate message = = = = = = = = = = = = = = = = = = = = = = = = = = 

		// Check result integer: ----------------------------------------------
		if(result <= 0){
			// Timeout or other error code. Exit function w/ error code.
			pl;printf(
				"\n\r[%08dms][R] Receive timeout or network error: \n\r\t\"%s\""
				,tm, this->_interpret(result));pu;
				
			return result;
			
		} // Done checking result integer: -------------------------------------
		// Split message: ------------------------------------------------------
		received[result] = '\0';
		
		pl;printf("\n\r[%08dms][R] Received: %s (%d)", tm,received, result);pu;

		char* splitPosition;
			// NOTE: Use strtok_r instead of strtok for thread-safety
		ptr = strtok_r(received,"|", &splitPosition);
		
		// Get index: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
		if(ptr != NULL){
			*receivedIndex = atoi(ptr);
		}
		
		// Check index: - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
		if(*receivedIndex == 0){
			// Zero index might indicate HSK. Raise HSK flag.
			hsk = true;
			pl;printf("\n\r[%08dms][R] Zero index. HSK flag raised",
				tm);pu;
		}
		else if((*receivedIndex <= *currentIndex) or (ptr == NULL)){
			// Bad index:
			pl;printf("\n\r[%08dms][R] Bad recv'd index (%d): expected %d",tm,
				ptr == NULL? 0 : *receivedIndex, *currentIndex + 1);pu;

			// Restart loop:
			continue;
		}
		// Check keyword: - - - - - - - - - - - - - - - - - - - - - - - - - - - 
		ptr = strtok_r(NULL, "|", &splitPosition);

		if(ptr != NULL and strlen(ptr) == 4){
			strcpy(keyword, ptr);
		}
		else{
			// Bad keyword: 
			pl;printf("\n\r[%08dms][R] Bad recv'd keyword (%s)",tm,
				ptr == NULL? "[NULL]" : keyword);pu;

			// Restart loop:
			continue;
		}

		// Check HSK flag:
		if(hsk and strcmp(keyword, "MHSK") != 0){
			// Have zero index but non-HSK keyword. (Invalid)
			pl;printf("\n\r[%08dms][R] Zero index w/o MHSK. Message discarded",
				tm);pu;

			// Restart loop:
			continue;
		}
		

		// Check command: - - - - - - - - - - - - - - - - - - - - - - - - - - - 
		ptr = strtok_r(NULL, "|", &splitPosition);

		if(ptr != NULL){

			strcpy(command, ptr);
			
		}else{
			command[0] = '\0';
		}

		

		// Reset corresponding timeout: - - - - - - - - - - - - - - - - - - - - 
		if(this->getStatus() == CONNECTED){

			// Increment Master timeouts:
			this->_resetTimeouts();

		}else{


			} // End increment timeout - - - - - - - - - - - - - - - - - - - - 

		// Update index upon success: - - - - - - - - - - - - - - - - - - - - - 
		*currentIndex = *receivedIndex;

		// Break from loop:
		break;
		} // End receive loop /=================================================
	return result;		  
