
//////////////////////////////////////////////////////////////////////////////// 
// ABOUT: PROSPECTIVE COMMUNICATIONS PROTOCOL:                                //
/*                                                                             
        NOTE: SLAVES MAY TIME OUT AND START THEIR PROCESS ANEW AT ANY
        POINT IN THE PROCESS. MASTER MAY CONNECT TO NEW SLAVES OR RE-
        CONNECT OLD ONES AT ANY POINT.

        1.- Both Master and Slaves initialize their Ethernet interfaces and UDP-
            sockets and await further instructions.
            
            1.1.-**  Here, slaves may be set to "USB Mode."
            
        2.- Master begins an UDP broadcast upon user command (unless  otherwise 
            configured.
            
        3.- Slaves receive broadcast, save Master's address and send reply.
        
        4.- Master receives replies from available Slaves and decides to which
            to connect, if any.
            
        5.- For each slave:
            
            5.1 Master sends message to accepted Slaves, including port to be used
                for future communications.
        
            5.2 Both Master and Slave switch to TCP Sockets initialized in the 
                same network interface but with the port agreed in 5.1
        
            5.3 Master and slaves proceed to TCP "handshake"
            
*/                                                                             
//                                                                            //
////////////////////////////////////////////////////////////////////////////////    
    
    // SET UP REFERENCE TIMER:
    Timer t;
    t.start();
    
    // INITIALIZE ETHERNET INTERFACE -------------------------------------------
    printf("\n\r%010d Initializing ethernet...",t.read_ms());
    EthernetInterface ethernet;
    
    
    // Verify success:
    if( int eth_result = ethernet.connect() < 0){
        printf("\n\r%010d ERROR (RIP ethernet): %d", t.read_ms(), eth_result);
        wait(3);
        NVIC_SystemReset();
    }//(end check eth_result)
    
    printf("\n\r%010d IP IS: %s", t.read_ms(), ethernet.get_ip_address());
    printf("\n\r%010d MAC IS: %s", t.read_ms(), ethernet.get_mac_address());
    
    
    // INITIALIZE UDP SOCKET ---------------------------------------------------
    UDPSocket udp; // Initialize socket on ethernet interface
    printf("\n\r%010d UDP init", t.read_ms());
    udp.open(&ethernet);
    printf("\n\r%010d UDP open", t.read_ms());
    udp.bind(65000); // bind socket to arbitrary port with no IP
    printf("\n\r%010d UDP port set", t.read_ms());
    SocketAddress masterUDP; // Address of Master during UDP broadcast
    printf("\n\r%010d SOCKET INITIALIZED", t.read_ms());
    
    printf("\n\r%010d Setting buffer", t.read_ms());
    
    // Create TCP Socket to be initialized within loop:
    TCPSocket tcp;
    
    // INIT LOOP ---------------------------------------------------------------
    int comms_port = 0;
    printf("\n\r%010d Buffer set", t.read_ms());
    
    printf("\n\r%010d WAITING FOR BROADCAST", t.read_ms());
    wait(0.1);
    while(true){
        char buffer[16];
        printf("\n\r%010d WAITING FOR BROADCAST", t.read_ms());
        int n = udp.recvfrom(&masterUDP, buffer, 256);
        
        if(n > 0){
            printf("\n\r%010d RECEIVED:\n\r\t%s\n\r\tFROM IP:%s",
                t.read_ms(), buffer, masterUDP.get_ip_address());
            comms_port = atoi(buffer);
            // Validate
            if( comms_port < 0){
                printf("\n\r%010d Validation error: %d", t.read_ms(), comms_port);
                continue;
            }
            else{
                // If port may work, attempt to initialize TCP socket
                printf("\n\r%010d Trying to initialize TCP with %s on port %d",
                    t.read_ms(), masterUDP.get_ip_address(), comms_port);
                tcp.open(&ethernet);
                printf("\n\r%010d TCP open", t.read_ms());
                tcp.bind(comms_port);
                printf("\n\r%010d TCP binded to port %d", t.read_ms(), comms_port);
                
                printf("\n\r%010d Attempting connection now\n\r", t.read_ms());
                
                tcp.set_timeout(-1);
                int i = 0;
                while(tcp.connect(masterUDP.get_ip_address(), comms_port) < 0){
                    printf("\r%d",i++);
                    wait(0.5);
                    
                    if(i > 20){
                        printf("\n\r%010d TCP timed out. Restarting search", t.read_ms());
                        tcp.close();
                        continue;
                    }//(end if i>20)
                    
                }//(end while connecting)
                wait(0.5);
                printf("\n\r CONNECTED, BOII");
                printf("\n\r CONNECTED, BOII");
                wait(0.5);
                tcp.close();
                return 1;
          }//(end else)      
                
            
            
        }//(end if n>0)
    
    }//(end UDP loop)
